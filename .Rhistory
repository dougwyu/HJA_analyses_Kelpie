xy.sf <- st_as_sf(S.train, coords = c("UTM_E", "UTM_N"), crs = nadutm10)
rm(S.train)
# transform to wgs utm to match rasters
xy.utm <- st_transform(xy.sf, crs = utm10N)
rm(xy.sf)
utm10N <- 32610
# EPSG:26910  NAD83 / UTM zone 10N # original coordinates of sample poitns are in this proejction - Marie
nadutm10 <- 26910
gis <- file.path(wd, "HJA_scripts/10_eo_data/raw_gis_data")
# gis is organised by shape (vector) / raster folders, according to projection
dir(gis)
# raster files are here:
dir(file.path(gis, "r_utm"))
### Load data ###
# load sample points:
head(S.train)
# convert to sf spatial data frame
xy.sf <- st_as_sf(S.train, coords = c("UTM_E", "UTM_N"), crs = nadutm10)
source("Hmsc_CD/local/L1_read_data_v3.r") # reads all data, covariates, etc. from github
rm(wd)
rm(Y.train.pa, Y.train.qp, P, otu.pa.csv, otu.qp.csv, otu.ab.csv, X.train, topo.df, otuenv)
head(S.train)
# convert to sf spatial data frame
xy.sf <- st_as_sf(S.train, coords = c("UTM_E", "UTM_N"), crs = nadutm10)
rm(S.train)
# transform to wgs utm to match rasters
xy.utm <- st_transform(xy.sf, crs = utm10N)
rm(xy.sf)
covStack <- stack(file.path(gis, "r_utm", c("lidar_metric_mosaic_p95.tif",
"lidar_metric_mosaic_Cover_2m_4m.tif",
"lidar_metric_mosaic_Cover_4m_16m.tif")))
covStack
names(covStack) <- c("p95", "cov2_4", "cov4_16")
covStack
cov.pts <- raster::extract(covStack, xy.utm)
head(cov.pts)
head(env.vars)
xy.utm
cov.pts <- raster::extract(covStack, xy.utm, df = T)
head(cov.pts)
cov.pts <- raster::extract(covStack, xy.utm, sp = T)
cov.pts
cov.pts <- st_as_sf(raster::extract(covStack, xy.utm, sp = T))
head(cov.pts)
head(env.vars)
source('J:/UEA/gitHRepos/HJA_analyses_Kelpie/HJA_scripts/10_eo_data/compare_lidar.r', echo=TRUE)
getwd()
wd <- here::here()
setwd(wd)
dir()
library(sf)
library(raster)
# wgs84 UTM 10N
utm10N <- 32610
# EPSG:26910  NAD83 / UTM zone 10N # original coordinates of sample poitns are in this proejction - Marie
nadutm10 <- 26910
gis <- file.path(wd, "HJA_scripts/10_eo_data/raw_gis_data")
gis <- file.path(wd, "HJA_scripts/10_eo_data/raw_gis_data") # originally stored locally
# gis is organised by shape (vector) / raster folders, according to projection
dir(gis)
# raster files are here:
dir(file.path(gis, "r_utm"))
### Load data ###
# load sample points:
# get data
source("Hmsc_CD/local/L1_read_data_v3.r") # reads all data, covariates, etc. from github
rm(Y.train.pa, Y.train.qp, P, otu.pa.csv, otu.qp.csv, otu.ab.csv, X.train, topo.df, otuenv)
head(S.train)
# convert to sf spatial data frame
xy.sf <- st_as_sf(S.train, coords = c("UTM_E", "UTM_N"), crs = nadutm10)
rm(S.train)
# transform to wgs utm to match rasters
xy.utm <- st_transform(xy.sf, crs = utm10N)
rm(xy.sf)
xy.utm
# load p95 lidar raster
covStack <- stack(file.path(gis, "r_utm", c("lidar_metric_mosaic_p95.tif",
"lidar_metric_mosaic_Cover_2m_4m.tif",
"lidar_metric_mosaic_Cover_4m_16m.tif")))
names(covStack) <- c("p95", "cov2_4", "cov4_16")
covStack
# extract lidar data at
cov.pts <- st_as_sf(raster::extract(covStack, xy.utm, sp = T)) # extract, reconvert to sf to get all columns in result
head(cov.pts)
#
head(env.vars)
mData <- env.vars %>%
dplyr::select(UniqueID, l_p95, l_Cover_2m_4m, l_Cover_4m_16m) %>%
dplyr::left_join(y = cov.pts) %>%
as.data.frame()
mData <- env.vars %>%
dplyr::select(uniqueID, l_p95, l_Cover_2m_4m, l_Cover_4m_16m) %>%
dplyr::left_join(y = cov.pts) %>%
as.data.frame()
head(mData)
pairs(mData)
mData %>%
select(where(is.numeric))
mData %>%
dplyr::select(where(is.numeric))
mData %>%
dplyr::select(where(is.numeric)) %>%
pairs()
load("Hmsc_CD/oregon_ada/results_sjSDM/oregon_trial_tune.rdata")
Y.test <- Y.train.pa.min10[tune_results$tune_results[[1]][[1]]$indices, ]
setwd("J:/UEA/gitHRepos/HJA_analyses_Kelpie/Hmsc_CD/oregon_ada")
source("code_sjSDM/S1_read_data.r")
setwd("J:/UEA/gitHRepos/HJA_analyses_Kelpie")
raretaxa <- which(colSums(Y.train.pa > 0) < 10)
length(raretaxa)
Y.train.pa.min10 <- as.matrix(Y.train.pa[, -raretaxa]) # reduced species
rm(raretaxa)
Y.test <- Y.train.pa.min10[tune_results$tune_results[[1]][[1]]$indices, ]
Y.train <- Y.train.pa.min10[-tune_results$tune_results[[1]][[1]]$indices, ]
pred.test <- tune_results$tune_results[[1]][[1]]$pred_test
Pred.test <- pred.test
getwd()
save(Y.test, Pred.test, file = "Hmsc_CD/local/test_example.rdata")
Y.test[,1:5]
Pred.test[,1:5]
unname(Y.test[,1:5])
readline()
readChar("hello")
raw("hello")
dput(Y.test[,1])
Y.tst <- c(`1` = 1, `15` = 0, `32` = 0, `34` = 1, `35` = 0, `48` = 1,
`52` = 1, `54` = 1, `56` = 1, `59` = 1, `67` = 1, `73` = 0, `77` = 0,
`79` = 0, `80` = 1, `82` = 1, `84` = 1)
Y.tst
Y.test[,1]
Y.test <- unname(Y.test[,1:5])
row.names(Y.test) <- NULL
Pred.test[,1:5]
Y.test
dput(Y.test)
dput(Pred.test)
dput(Pred.test[,1:5])
dput(round(Pred.test[,1:5],5))
Y.test <- structure(c(1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,
0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,
0, 0, 0, 0, 0), .Dim = c(17L, 5L))
Pred.test <- structure(c(0.93892, 0.66146, 0.47845, 0.84288, 0.3483, 0.415,
0.97109, 0.91469, 0.86533, 0.76702, 0.6164, 0.91962, 0.78906,
0.91927, 0.73108, 0.83802, 0.92296, 0.60071, 0.13734, 0.29069,
0.35382, 0.11483, 0.17761, 0.3793, 0.15075, 0.41787, 0.33493,
0.24288, 0.14474, 0.19351, 0.33881, 0.13977, 0.11995, 0.12558,
0.53059, 0.85161, 0.84674, 0.95095, 0.81294, 0.99165, 0.34469,
0.85878, 0.65415, 0.42095, 0.92685, 0.89672, 0.88219, 0.85416,
0.97768, 0.97595, 0.91641, 0.34734, 0.18854, 0.10646, 0.27799,
0.28179, 0.48508, 0.11032, 0.24834, 0.14395, 0.18885, 0.21009,
0.18454, 0.16242, 0.21792, 0.26658, 0.19304, 0.14045, 0.16228,
0.09252, 0.16617, 0.10135, 0.04972, 0.00968, 0.40565, 0.1477,
0.48642, 0.21742, 0.13046, 0.19929, 0.26912, 0.28597, 0.06011,
0.1294, 0.20422), .Dim = c(17L, 5L), .Dimnames = list(NULL, NULL))
head(Y.tes)
head(Y.test)
head(Pred.test)
i = 1
Metrics::auc(Y.test[,i],Pred.test[,i])
pROC::roc(response = Y.test[,i], predictor = Pred.test[,i])
sapply(1:ncol(pred_data), function(i) Metrics::auc(obs_data[,i],pred_data[,i]))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
sapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i])$auc)
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
lapply(rocList, plot)
str(rocList)
text(1, 0.8, x$auc$direction)
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, x$auc$direction)
})
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, x["auc"]auc$direction)
})
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, x["auc"]$direction)
})
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, x["auc"]["direction"])
})
x <- rocList[[1]]
str(x)
str(x$auc)
attr(x["auc"], "direction")
attr(x["auc"], "roc")
x["auc"]
attr(x[["auc"]], "roc")
text(1, 0.8, x["direction"])
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, paste("direction:", x["direction"])
})
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, paste("direction:", x["direction"]))
})
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
lapply(rocList, function(x) {
plot(x)
text(1, 0.8, paste("direction:", x["direction"]))
})
par(mfrow = c(2,2))
lapply(rocList[1:4], function(x) {
plot(x)
text(1, 0.8, paste("direction:", x["direction"]))
})
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i], direction = "<")$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i], direction = "<")$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
mapply(function(x,y) boxplot(x ~ y), Pred.test, Y.test)
lapply(1:4, function(i) boxplot(Pred.test[,i], Y.test[,i]))
for(1:4){
plot(rocList[i])
text(1, 0.8, paste("direction:", rocList[i]["direction"]))
boxplot(Pred.test[,i], Y.test[,i]))
}
i = 1
plot(rocList[i])
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[i]["direction"]))
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i], Y.test[,i]))
boxplot(Pred.test[,i] ~ Y.test[,i])
par(mfrow = c(2,2))
for(1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
par(mfcol = c(2,2))
for(i in 1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
Y.test <- unname(Y.test[,1:4])
row.names(Y.test) <- NULL
dput(Y.test)
dput(round(Pred.test[,1:4],5))
# testing data response and predicted values from pa cross validation, 5 species
Y.test <- structure(c(1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,
0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0), .Dim = c(17L, 4L))
Pred.test <- structure(c(0.93892, 0.66146, 0.47845, 0.84288, 0.3483, 0.415,
0.97109, 0.91469, 0.86533, 0.76702, 0.6164, 0.91962, 0.78906,
0.91927, 0.73108, 0.83802, 0.92296, 0.60071, 0.13734, 0.29069,
0.35382, 0.11483, 0.17761, 0.3793, 0.15075, 0.41787, 0.33493,
0.24288, 0.14474, 0.19351, 0.33881, 0.13977, 0.11995, 0.12558,
0.53059, 0.85161, 0.84674, 0.95095, 0.81294, 0.99165, 0.34469,
0.85878, 0.65415, 0.42095, 0.92685, 0.89672, 0.88219, 0.85416,
0.97768, 0.97595, 0.91641, 0.34734, 0.18854, 0.10646, 0.27799,
0.28179, 0.48508, 0.11032, 0.24834, 0.14395, 0.18885, 0.21009,
0.18454, 0.16242, 0.21792, 0.26658, 0.19304, 0.14045),
.Dim = c(17L, 4L), .Dimnames = list(NULL, NULL))
head(Y.test)
head(Pred.test)
Y.test
Pred.test
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
par(mfcol = c(2,2))
for(i in 1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i], direction = "<")$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
wd <- here::here()
setwd(wd)
getwd()
setwd("J:/UEA/gitHRepos/HJA_analyses_Kelpie/Hmsc_CD/oregon_ada")
source("code_sjSDM/S1_read_data.r")
setwd("J:/UEA/gitHRepos/HJA_analyses_Kelpie")
raretaxa <- which(colSums(Y.train.pa > 0) < 10)
length(raretaxa)
Y.pa.min10 <- as.matrix(Y.train.pa[, -raretaxa]) # reduced species
rm(raretaxa)
# spatial data here:
head(S.train)
xy.scale <- scale(S.train[,c("UTM_E", "UTM_N")])
test.size <- floor(nrow(Y.pa.min10)*0.2)
train.size <- nrow(Y.pa.min10) - test.size
set.seed(99)
test.rows <- sample(1:nrow(Y.pa.min10), size = test.size)
train.rows <- setdiff(1:nrow(Y.pa.min10), test.rows)
# sort(c(test.rows, train.rows))
Y.test.pa.min10 <- Y.pa.min10[test.rows, ]
Y.train.pa.min10 <- Y.pa.min10[train.rows, ]
X.test <- env.vars[test.rows,]
X.train <- env.vars[train.rows,]
xy.train <- xy.scale[train.rows,]
xy.test <- xy.scale[test.rows,]
load("Hmsc_CD/oregon_ada/results_sjSDM/oregon_eval.rdata")
pred_data <- pred.link.test
obs_data <- Y.test.pa.min10
prob.cm <- function(pred_data, obs_data, model, p, k, metrics){
# p - number of predictors
# k - no estimated parameters
if(missing(metrics)) metrics <- c("TPR", "TPR", "TNR", "FNR", "Prev", "Acc", "Tjur", "AUC")
TP <- colSums(pred_data * obs_data) # sum of probability of presences at True presences
FP <- colSums(pred_data * (1 - obs_data)) # sum of prob of presences at True absences
TN <- colSums((1 - pred_data) * (1 - obs_data)) # sum of probability of absence at true absences
FN <- colSums((1 - pred_data) * obs_data) # sum of probability of absences at true presences
TPR <- tryCatch(expr = TP / (TP + FN),
error = function(err){ return(NA) })                          # True Positive Rate / Sensitivity
FPR <- tryCatch(expr = FP / (FP + TN),
error = function(err){ return(NA) })                         # False Positive Rate
TNR <- tryCatch(expr = TN / (FP + TN),
error = function(err){ return(NA) })                         # True Negative Rate / Specificity
FNR <- tryCatch(expr = FN / (TP + FN),
error = function(err){ return(NA) })                        # False Negative Rate
Prevalence <- tryCatch(expr = (TP + FN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Accuracy <- tryCatch(expr = (TP + TN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Tjur <- tryCatch(expr = mapply(function(x,y) {
tj <- base::diff(tapply(x, y, mean, na.rm = T)) # difference of average predicted values at 1 and 0
if(!length(tj) > 0) tj <- NA
return(tj)
}, asplit(pred_data,2), asplit(obs_data,2)), error = function(err){ return(NA)})
AUC <- tryCatch(expr = sapply(1:ncol(pred_data), function(i) Metrics::auc(obs_data[,i],pred_data[,i])),
error = function(err){ return(NA) })
# lawson et al 2014 Appendix S9
loglikP <- sum( log( pred_data * obs_data + (1-pred_data)*(1-obs_data) ) )
loglikN <- sum( log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) ) ) # NUll intercept only, (so mean)
rsq <- (loglikP-loglikN)/(1-loglikN)
n <- nrow(pred_data)
adjR2 <- 1-( (n-1)/(n-p) ) * (1-rsq)
# cm = cbind(TP=TP, FP=FP, TN=TN, FN=FN),
res <- cbind(TPR=TPR, FPR=FPR, TNR=TNR, FNR=FNR, Prev=Prevalence, Acc=Accuracy, Tjur=Tjur, AUC=AUC)
# subset, if required
res <- res[,metrics]
return(res)
}
prob.cm <- function(pred_data, obs_data, model, p, k, metrics){
# p - number of predictors
# k - no estimated parameters
if(nrow(pred_data) != nrow(obs_data)) stop("")
if(missing(metrics)) metrics <- c("TPR", "TPR", "TNR", "FNR", "Prev", "Acc", "Tjur", "AUC", "R2", "adjR2")
TP <- colSums(pred_data * obs_data) # sum of probability of presences at True presences
FP <- colSums(pred_data * (1 - obs_data)) # sum of prob of presences at True absences
TN <- colSums((1 - pred_data) * (1 - obs_data)) # sum of probability of absence at true absences
FN <- colSums((1 - pred_data) * obs_data) # sum of probability of absences at true presences
TPR <- tryCatch(expr = TP / (TP + FN),
error = function(err){ return(NA) })                          # True Positive Rate / Sensitivity
FPR <- tryCatch(expr = FP / (FP + TN),
error = function(err){ return(NA) })                         # False Positive Rate
TNR <- tryCatch(expr = TN / (FP + TN),
error = function(err){ return(NA) })                         # True Negative Rate / Specificity
FNR <- tryCatch(expr = FN / (TP + FN),
error = function(err){ return(NA) })                        # False Negative Rate
Prevalence <- tryCatch(expr = (TP + FN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Accuracy <- tryCatch(expr = (TP + TN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Tjur <- tryCatch(expr = mapply(function(x,y) {
tj <- base::diff(tapply(x, y, mean, na.rm = T)) # difference of average predicted values at 1 and 0
if(!length(tj) > 0) tj <- NA
return(tj)
}, asplit(pred_data,2), asplit(obs_data,2)), error = function(err){ return(NA)})
AUC <- tryCatch(expr = sapply(1:ncol(pred_data), function(i) Metrics::auc(obs_data[,i],pred_data[,i])),
error = function(err){ return(NA) })
# lawson et al 2014 Appendix S9
loglikP <- sum( log( pred_data * obs_data + (1-pred_data)*(1-obs_data) ) )
loglikN <- sum( log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) ) ) # NUll intercept only, (so mean)
rsq <- (loglikP-loglikN)/(1-loglikN)
n <- nrow(pred_data)
adjR2 <- 1-( (n-1)/(n-p) ) * (1-rsq)
# cm = cbind(TP=TP, FP=FP, TN=TN, FN=FN),
res <- cbind(TPR=TPR, FPR=FPR, TNR=TNR, FNR=FNR,
Prev=Prevalence, Acc=Accuracy,
Tjur=Tjur,
AUC=AUC,
R2 = rsq, adjR2 = adjR2)
# subset, if required
res <- res[,metrics]
return(res)
}
cm <- prob.cm(pred.link.test, Y.test.pa.min10)
cm <- prob.cm(pred.link.test, Y.test.pa.min10, p = 10)
head(cm)
loglikP <- sum( log( pred_data * obs_data + (1-pred_data)*(1-obs_data) ) )
log( pred_data * obs_data + (1-pred_data)*(1-obs_data) )
loglikP <- colSums( log( pred_data * obs_data + (1-pred_data)*(1-obs_data) ) )
log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) )
loglikN <- colSums( log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) ) ) # NUll intercept only, (so mean)
rsq <- (loglikP-loglikN)/(1-loglikN)
n <- nrow(pred_data)
adjR2 <- 1-( (n-1)/(n-p) ) * (1-rsq)
p = 10
adjR2 <- 1-( (n-1)/(n-p) ) * (1-rsq)
prob.cm <- function(pred_data, obs_data, model, p, k, metrics){
# p - number of predictors
# k - no estimated parameters
if(nrow(pred_data) != nrow(obs_data)) stop("")
if(missing(metrics)) metrics <- c("TPR", "TPR", "TNR", "FNR", "Prev", "Acc", "Tjur", "AUC", "R2", "adjR2")
TP <- colSums(pred_data * obs_data) # sum of probability of presences at True presences
FP <- colSums(pred_data * (1 - obs_data)) # sum of prob of presences at True absences
TN <- colSums((1 - pred_data) * (1 - obs_data)) # sum of probability of absence at true absences
FN <- colSums((1 - pred_data) * obs_data) # sum of probability of absences at true presences
TPR <- tryCatch(expr = TP / (TP + FN),
error = function(err){ return(NA) })                          # True Positive Rate / Sensitivity
FPR <- tryCatch(expr = FP / (FP + TN),
error = function(err){ return(NA) })                         # False Positive Rate
TNR <- tryCatch(expr = TN / (FP + TN),
error = function(err){ return(NA) })                         # True Negative Rate / Specificity
FNR <- tryCatch(expr = FN / (TP + FN),
error = function(err){ return(NA) })                        # False Negative Rate
Prevalence <- tryCatch(expr = (TP + FN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Accuracy <- tryCatch(expr = (TP + TN) / (TP + FP + TN + FN),
error = function(err){ return(NA) })
Tjur <- tryCatch(expr = mapply(function(x,y) {
tj <- base::diff(tapply(x, y, mean, na.rm = T)) # difference of average predicted values at 1 and 0
if(!length(tj) > 0) tj <- NA
return(tj)
}, asplit(pred_data,2), asplit(obs_data,2)), error = function(err){ return(NA)})
AUC <- tryCatch(expr = sapply(1:ncol(pred_data), function(i) Metrics::auc(obs_data[,i],pred_data[,i])),
error = function(err){ return(NA) })
# lawson et al 2014 Appendix S9
loglikP <- colSums( log( pred_data * obs_data + (1-pred_data)*(1-obs_data) ) )
loglikN <- colSums( log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) ) ) # NUll intercept only, (so mean)
rsq <- (loglikP-loglikN)/(1-loglikN)
n <- nrow(pred_data)
adjR2 <- 1-( (n-1)/(n-p) ) * (1-rsq)
# cm = cbind(TP=TP, FP=FP, TN=TN, FN=FN),
res <- cbind(TPR=TPR, FPR=FPR, TNR=TNR, FNR=FNR,
Prev=Prevalence, Acc=Accuracy,
Tjur=Tjur,
AUC=AUC,
R2 = rsq, adjR2 = adjR2)
# subset, if required
res <- res[,metrics]
return(res)
}
cm <- prob.cm(pred.link.test, Y.test.pa.min10, p = 10)
head(cm)
rsq <- 1 - (loglikN/loglikP)^(2/n)
(loglikN/loglikP)^(2/n)
rsq <- 1 - (loglikN/loglikP)^(2/n)
adjR2 <- rsq/(1 - (loglikN)^(2/n))
(loglikN)^(2/n)
loglikN
rsq <- 1 - (loglikN/loglikP)^(2/n)
adjR2 <- rsq/(1 - (loglikN)^(2/n))
loglikN <- colSums( log( mean(pred_data)*obs_data + (1-mean(pred_data))*(1-obs_data) ) ) # NUll intercept only, (so mean)
2/n
(loglikN)^(2/n)
-5^0.5
-5^0.1
2/17
-5^0.11
-13^0.11
-13^(2/n)
(loglikN)^(2/n)
loglikN^(2/n)
2/n
loglikN^(2/n)
# testing data: 17 sites (20%) with response and predicted values from pa cross validation, 4 species
Y.test <- structure(c(1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,
0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0), .Dim = c(17L, 4L))
Pred.test <- structure(c(0.93892, 0.66146, 0.47845, 0.84288, 0.3483, 0.415,
0.97109, 0.91469, 0.86533, 0.76702, 0.6164, 0.91962, 0.78906,
0.91927, 0.73108, 0.83802, 0.92296, 0.60071, 0.13734, 0.29069,
0.35382, 0.11483, 0.17761, 0.3793, 0.15075, 0.41787, 0.33493,
0.24288, 0.14474, 0.19351, 0.33881, 0.13977, 0.11995, 0.12558,
0.53059, 0.85161, 0.84674, 0.95095, 0.81294, 0.99165, 0.34469,
0.85878, 0.65415, 0.42095, 0.92685, 0.89672, 0.88219, 0.85416,
0.97768, 0.97595, 0.91641, 0.34734, 0.18854, 0.10646, 0.27799,
0.28179, 0.48508, 0.11032, 0.24834, 0.14395, 0.18885, 0.21009,
0.18454, 0.16242, 0.21792, 0.26658, 0.19304, 0.14045),
.Dim = c(17L, 4L), .Dimnames = list(NULL, NULL))
Y.test
Pred.test
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i]))
par(mfcol = c(2,2))
for(i in 1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i], direction = "<")$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i], direction = "<"))
par(mfcol = c(2,2))
for(i in 1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i], direction = "<")$auc))

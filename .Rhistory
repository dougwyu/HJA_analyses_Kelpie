samtoolsqual <- "q48"
minimaprundate <- 20200929
kelpierundate <- 20200927
primer <- "BF3BR2"
abund = 'pa' # pa , qp
gitHub <- "https://raw.githubusercontent.com/dougwyu/HJA_analyses_Kelpie/master/Kelpie_maps"
outputidxstatstabulatefolder <- paste0("outputs_minimap2_",minimaprundate,"_",samtoolsfilter,"_",
samtoolsqual, "_kelpie", kelpierundate,"_", primer,"_vsearch97")
datFile <- paste0("sample_by_species_table_", samtoolsfilter, "_minimap2_", minimaprundate,"_kelpie",
kelpierundate,"_FSL_qp.csv")
fn <- file.path(gitHub, outputidxstatstabulatefolder, datFile)
# what file am i using?
basename(fn)
# when was it modified?
file.mtime(fn)
# read complete data set
otuenv <- read.csv(fn, stringsAsFactors = FALSE, na.strings = "NA")
trap <- "M1"
period <- "S1"
otuenv <- otuenv %>%
dplyr::filter(trap == trap[[1]] & period == period[[1]])
# clean up
rm(datFile, gitHub, kelpierundate, minimaprundate, outputidxstatstabulatefolder, period, primer, samtoolsfilter, samtoolsqual, trap, fn)
# keep OTUs with >=5 incidences
minocc <- 5 # set to high number (e.g. 20) for testing
otu.qp.csv <- otuenv %>% dplyr::select(contains("__")) ## file above is already qp
otu.qp.csv <- otu.qp.csv[ , colSums(otu.qp.csv > 0) >= minocc]
# convert to presence/absence data
otu.pa.csv <- otu.qp.csv
otu.pa.csv[otu.pa.csv > 0] <- 1
min(colSums(otu.pa.csv)) == minocc # should be TRUE
rm(minocc)
env.vars <- otuenv %>%
dplyr::select(!contains("__"), -UTM_E, -UTM_N, -starts_with("nor")) %>%
mutate(uniqueID = paste(SiteName, trap, period, sep = "_"),
elevation_m = elevation_f * 0.3048, ## convert to metres
canopyHeight_m = canopyHeight_f * 0.3048,
B1_median = apply(across(starts_with("B1_")), 1, median),
B2_median = apply(across(starts_with("B2_")), 1, median),
B3_median = apply(across(starts_with("B3_")), 1, median),
B4_median = apply(across(starts_with("B4_")), 1, median),
B5_median = apply(across(starts_with("B5_")), 1, median),
B6_median = apply(across(starts_with("B6_")), 1, median),
B7_median = apply(across(starts_with("B7_")), 1, median),
B10_median = apply(across(starts_with("B10_")), 1, median),
B11_median = apply(across(starts_with("B11_")), 1, median),
lg_DistStream = log(distToStream_m + 0.001),
lg_DistRoad = log(distToRoad_m + 0.001),
lg_YrsDisturb = log(YrsSinceDist + 0.001),
lg_cover2m_max = log(l_Cover_2m_max + 0.001),
lg_cover2m_4m = log(l_Cover_2m_4m + 0.001),
lg_cover4m_16m = log(l_Cover_4m_16m + 0.001)) %>%
dplyr::select(uniqueID, clearcut,insideHJA,oldGrowthIndex, elevation_m, canopyHeight_m, precipitation_mm, minT_annual,
maxT_annual, mean.NDVI, mean.EVI, mean.green, mean.wet, mean.bright, l_p25, l_p95, l_rumple, B1_median,
B2_median,B3_median,B4_median,B5_median,B6_median,B7_median,B10_median,B11_median,lg_DistStream,
lg_DistRoad, lg_YrsDisturb, lg_cover2m_max, lg_cover2m_4m, lg_cover4m_16m, l_Cover_2m_4m,l_Cover_4m_16m,
be10, tri, slope, Nss, Ess, ht, ht.r250, ht.r500, ht.r1k, cov2_4, cov2_4.r250, cov2_4.r500, cov2_4.r1k,
cov4_16, cov4_16.r250, cov4_16.r500, cov4_16.r1k, be500, mTopo, cut.r1k.pt,B1_20180717, B2_20180717,
B3_20180717, B4_20180717, B5_20180717, B6_20180717, B7_20180717, B10_20180717, B11_20180717, NDVI_20180717,
EVI_20180717, B_20180717, G_20180717, W_20180717) %>%
mutate(
#across(where(is.numeric), scale), # scale here # scale when defining models etc.
clearcut = factor(clearcut),
insideHJA = factor(insideHJA))
#dplyr::select(-uniqueID)
str(env.vars)
summary(env.vars)
env.vars <- otuenv %>%
dplyr::select(!contains("__"), -UTM_E, -UTM_N, -starts_with("nor")) %>%
mutate(uniqueID = paste(SiteName, trap, period, sep = "_"),
elevation_m = elevation_f * 0.3048, ## convert to metres
canopyHeight_m = canopyHeight_f * 0.3048,
B1_median = apply(across(starts_with("B1_")), 1, median),
B2_median = apply(across(starts_with("B2_")), 1, median),
B3_median = apply(across(starts_with("B3_")), 1, median),
B4_median = apply(across(starts_with("B4_")), 1, median),
B5_median = apply(across(starts_with("B5_")), 1, median),
B6_median = apply(across(starts_with("B6_")), 1, median),
B7_median = apply(across(starts_with("B7_")), 1, median),
B10_median = apply(across(starts_with("B10_")), 1, median),
B11_median = apply(across(starts_with("B11_")), 1, median),
lg_DistStream = log(distToStream_m + 0.001),
lg_DistRoad = log(distToRoad_m + 0.001),
lg_YrsDisturb = log(YrsSinceDist + 0.001),
lg_cover2m_max = log(l_Cover_2m_max + 0.001),
lg_cover2m_4m = log(l_Cover_2m_4m + 0.001),
lg_cover4m_16m = log(l_Cover_4m_16m + 0.001)) %>%
dplyr::select(uniqueID, clearcut,insideHJA,oldGrowthIndex, elevation_m, canopyHeight_m, precipitation_mm, minT_annual,
maxT_annual, mean.NDVI, mean.EVI, mean.green, mean.wet, mean.bright, l_p25, l_p95, l_rumple, B1_median,
B2_median,B3_median,B4_median,B5_median,B6_median,B7_median,B10_median,B11_median,lg_DistStream,
lg_DistRoad, lg_YrsDisturb, lg_cover2m_max, lg_cover2m_4m, lg_cover4m_16m, l_Cover_2m_4m,l_Cover_4m_16m,
be10, tri, slope, twi, Nss, Ess, ht, ht.r250, ht.r500, ht.r1k, cov2_4, cov2_4.r250, cov2_4.r500, cov2_4.r1k,
cov4_16, cov4_16.r250, cov4_16.r500, cov4_16.r1k, be500, mTopo, cut.r1k.pt,B1_20180717, B2_20180717,
B3_20180717, B4_20180717, B5_20180717, B6_20180717, B7_20180717, B10_20180717, B11_20180717, NDVI_20180717,
EVI_20180717, B_20180717, G_20180717, W_20180717) %>%
mutate(
#across(where(is.numeric), scale), # scale here # scale when defining models etc.
clearcut = factor(clearcut),
insideHJA = factor(insideHJA))
#dplyr::select(-uniqueID)
summary(env.vars)
Sp.data <- otuenv %>%
dplyr::select(SiteName,trap,period, UTM_E, UTM_N) %>%
mutate(uniqueID = paste(SiteName, trap, period, sep = "_"))
head(Sp.data)
spp <- data.frame(species = colnames(otu.pa.csv)) %>%
tidyr::separate(col = species, into = c("OTU", "empty", "class", "order", "family",
"genus", "epithet", "BOLD", "BOLDID",
"size"),
remove = FALSE, sep = "_") %>%
dplyr::select(-empty)
head(spp)
for(c in seq_along(spp)[-1]) spp[,c] <- sub("NA", NA, spp[,c])
spp$family[is.na(spp$family)] <- sprintf("fam%03d", 1:sum((is.na(spp$family))))
spp$genus[is.na(spp$genus)] <- sprintf("gen%03d", 1:sum((is.na(spp$genus))))
head(spp)
# convert to factors for ape
spp <- spp[order(spp$class, spp$order, spp$family, spp$genus),]
tax.cols <- c("class", "order", "family", "genus", "epithet", "species")
for(i in tax.cols) spp[,i] <- factor(spp[,i])
head(spp)
P <- ape::as.phylo(~class/order/family/genus/species, data = spp, collapse = F)
P$edge.length = rep(1, length(P$edge)) # make all lengths eqaul between tax levels
ape::is.rooted(P)
all(P$tip.label %in% colnames(Y.train.pa))
all(P$tip.label %in% colnames(Y.train.qp))
all(P$tip.label %in% colnames(otu.pa.csv))
all(P$tip.label %in% colnames(otu.qp.csv))
rm(c, i, tax.cols, spp)
rm(otuenv)
source('J:/UEA/gitHRepos/HJA_analyses_Kelpie/Hmsc_CD/local/L1_read_data_v3.r', echo=TRUE)
packageVersion("sjSDM")
library(sjSDM)
source("Hmsc_CD/local/L1_read_data_v3.r")
raretaxa <- which(colSums(otu.pa.csv > 0) < 10)
length(raretaxa)
Y.train.pa_min10 <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
XFormula1 <- as.formula(~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 + cov4_16 + cov4_16.r500 + mTopo)
all(all.vars(XFormula1) %in% names(env.vars))
str(X.train)
mm <- model.matrix(XFormula1, data = env.vars)
head(mm)
env.vars.scale <- env.vars %>%
mutate(across(where(is.numeric), scale))
mm <- model.matrix(XFormula1, data = env.vars.scale)
head(mm)
head(S.train)
head(Sp.data)
Sp.data.scale <- Sp.data %>%
mutate(across(where(is.numeric), scale))
head(Sp.data.scale)
model <- sjSDM(Y = Y.train.pa_min10,
env = linear(data = env.vars.scale,
formula = ~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 +
cov4_16 + cov4_16.r500 + mTopo), # linear model on env covariates
spatial = linear(data = Sp.data.scale, formula = ~0+UTM_E:UTM_N), # interactions of coordinates
se = TRUE, family=binomial("probit"), sampling = 10L,
device = "cpu")
summary(model)
plot(imp)
imp = importance(model)
print(imp)
plot(imp)
an = anova(model)
raretaxa <- which(colSums(otu.pa.csv > 0) < 20)
length(raretaxa)
ncol(otu.pa.csv) - length(raretaxa)
raretaxa <- which(colSums(otu.pa.csv > 0) < 20)
# no of species remaining
ncol(otu.pa.csv) - length(raretaxa)
Y.train.pa_min10 <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
raretaxa <- which(colSums(otu.pa.csv > 0) < 25)
ncol(otu.pa.csv) - length(raretaxa)
Y.train.pa_min10 <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
otu.pa.min10 <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
ncol(otu.pa.csv) - length(raretaxa)
raretaxa <- which(colSums(otu.pa.csv > 0) < 25)
# no of species remaining
ncol(otu.pa.csv) - length(raretaxa)
otu.pa.min10 <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
otu.pa.minocc <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
raretaxa <- which(colSums(otu.pa.csv > 0) < 25)
# no of species remaining
ncol(otu.pa.csv) - length(raretaxa)
otu.pa.minocc <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
colSums(otu.pa.minocc)
sum(colSums(otu.pa.minocc) == 0)
minocc <- 25
raretaxa <- which(colSums(otu.pa.csv > 0) < minocc)
ncol(otu.pa.csv) - length(raretaxa)
otu.pa.minocc <- as.matrix(otu.pa.csv[, -raretaxa]) # reduced species
rm(raretaxa)
sum(colSums(otu.pa.minocc) == 0)
sum(rowSums(otu.pa.minocc) == 0)
model <- sjSDM(Y = Y.train.pa_min10,
env = linear(data = env.vars.scale,
formula = ~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 +
cov4_16 + cov4_16.r500 + mTopo), # linear model on env covariates
spatial = linear(data = Sp.data.scale, formula = ~0+UTM_E:UTM_N), # interactions of coordinates
se = TRUE, family=binomial("probit"), sampling = 100L, iter = 50L,
device = "cpu")
summary(model)
coef(model)
imp = importance(model)
print(imp)
plot(imp)
an = anova(model)
save(model, an, imp, otu.pa.minocc, Sp.data, env.vars, file = "Hmsc_CD/local/sjSDM_local/trial29_res.rdata")
tune_results = sjSDM_cv(Y = otu.pa_minocc,
env = linear(data = env.vars.scale,
formula = ~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 +
cov4_16 + cov4_16.r500 + mTopo),
spatial = linear(Sp.data.scale, ~0 + UTM_E:UTM_N),
biotic = bioticStruct(on_diag = FALSE, inverse = FALSE), # inverse=TRUE is 'better' but much slower
tune = "random", # random steps in tune-parameter space
learning_rate = 0.003, # 0.01 default, 0.003 recommended for high species number
family = stats::binomial("probit"), # for both p/a and quasiprob data, default
CV = 3L, #  5L for 5-fold cross validation, nrow(as.matrix(otu.data)) for LOOCV
tune_steps = 5L, # 20L is default - is this the number of tunes for random search???
alpha_cov = seq(0, 1, 0.2), # species regularisation
alpha_coef = seq(0, 1, 0.2), # env reg
alpha_spatial = seq(0, 1, 0.2), # spatial reg
lambda_cov = seq(0, 0.1, 0.01),
lambda_coef = seq(0, 0.1, 0.01),
lambda_spatial = seq(0,0.1,0.01),
device = "cpu",
n_cores = 2L, #
iter = 50L, # 2L
sampling = 100L # default is 5000L
)
tune_results = sjSDM_cv(Y = otu.pa.minocc,
env = linear(data = env.vars.scale,
formula = ~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 +
cov4_16 + cov4_16.r500 + mTopo),
spatial = linear(Sp.data.scale, ~0 + UTM_E:UTM_N),
biotic = bioticStruct(on_diag = FALSE, inverse = FALSE), # inverse=TRUE is 'better' but much slower
tune = "random", # random steps in tune-parameter space
learning_rate = 0.003, # 0.01 default, 0.003 recommended for high species number
family = stats::binomial("probit"), # for both p/a and quasiprob data, default
CV = 3L, #  5L for 5-fold cross validation, nrow(as.matrix(otu.data)) for LOOCV
tune_steps = 5L, # 20L is default - is this the number of tunes for random search???
alpha_cov = seq(0, 1, 0.2), # species regularisation
alpha_coef = seq(0, 1, 0.2), # env reg
alpha_spatial = seq(0, 1, 0.2), # spatial reg
lambda_cov = seq(0, 0.1, 0.01),
lambda_coef = seq(0, 0.1, 0.01),
lambda_spatial = seq(0,0.1,0.01),
device = "cpu",
n_cores = 2L, #
iter = 50L, # 2L
sampling = 100L # default is 5000L
)
closeAllConnections()
tune_results = sjSDM_cv(Y = otu.pa.minocc,
env = linear(data = env.vars.scale,
formula = ~be10+B11_median+mean.EVI+insideHJA + Ess + ht + ht.r500 +
cov4_16 + cov4_16.r500 + mTopo),
spatial = linear(Sp.data.scale, ~0 + UTM_E:UTM_N),
biotic = bioticStruct(on_diag = FALSE, inverse = FALSE), # inverse=TRUE is 'better' but much slower
tune = "random", # random steps in tune-parameter space
learning_rate = 0.003, # 0.01 default, 0.003 recommended for high species number
family = stats::binomial("probit"), # for both p/a and quasiprob data, default
CV = 5L, #  5L for 5-fold cross validation, nrow(as.matrix(otu.data)) for LOOCV
tune_steps = 5L, # 20L is default - is this the number of tunes for random search???
alpha_cov = seq(0, 1, 0.2), # species regularisation
alpha_coef = seq(0, 1, 0.2), # env reg
alpha_spatial = seq(0, 1, 0.2), # spatial reg
lambda_cov = seq(0, 0.1, 0.01),
lambda_coef = seq(0, 0.1, 0.01),
lambda_spatial = seq(0,0.1,0.01),
device = "cpu",
n_cores = 2L, #
iter = 100L, # 2L
sampling = 1000L # default is 5000L
)
save(tune_results, file = "Hmsc_CD/local/sjSDM_local/trial29_tune.rdata")
set.seed(999)
set.seed(101)
n <- 5
np <- rep(floor(runif(n, 10,60)))
np <- floor(runif(n, 10,60))
set.seed(101)
n <- 5
np <- floor(runif(n, 10,60))
n.occ <- 100
na <- n.occ - n.sp
n.spp <- 5
na <- n.occ - np
set.seed(101)
n.spp <- 5
n.occ <- 100
np <- floor(runif(n, 20,60))
na <- n.occ - np
c(np*1, na*0)
seq_len(np)*1
pa = rep(c(1,0), each = c(np, na))
rep(c(1,0), c(np, na))
pa = mapply(function(x,y) rep(c(1,0), c(x, y)), na, np)
pa
rep(c(1,0), c(66, 34))
pa <- mapply(function(x,y) rep(c(1,0), c(x, y)), np, na)
rbind(c(0.5, 0.5),
c(0.8, 0.6),
c(0.3, 0.7),
c(0.7, 0.4),
c(0.4, 0.8))
cbind(p.p, p.a)
p.p <- c(0.5, 0.8,0.3, 0.7,0.4)
p.a <- c(0.5, 0.6,0.7, 0.4,0.8)
cbind(p.p, p.a)
mapply(function(x,y) rnorm(x, y, 0.01), np, p.p)
mapply(function(w,x,y,z) c(rnorm(w, x, 0.01),
rnorm(y, z, 0.01)), np, p.p, na, p.a)
val <- mapply(function(w,x,y,z) c(rnorm(w, x, 0.01),
rnorm(y, z, 0.01)), np, p.p, na, p.a)
df1 <- data.frame(rep(species = letters[1:5], each = n.occ),
pa = as.vector(pa),
value = as.vector(val))
df1 <- data.frame(species = rep(letters[1:5], each = n.occ),
pa = as.vector(pa),
value = as.vector(val))
head(df1)
library(ggplot2)
ggplot(df1, aes(x = pa, y = value))+
geom_boxplot()+
geom_facet(~species)
ggplot(df1, aes(x = pa, y = value))+
geom_boxplot()+
facet_wrap(~species)
ggplot(df1, aes(x = as.factor(pa), y = value))+
geom_boxplot()+
facet_wrap(~species)
set.seed(101)
n.spp <- 5
n.occ <- 100
np <- floor(runif(n, 20,60))
na <- n.occ - np
pa <- mapply(function(x,y) rep(c(1,0), c(x, y)), np, na)
p.p <- c(0.5, 0.8,0.3, 0.7,0.4)
p.a <- c(0.5, 0.6,0.7, 0.4,0.8)
cbind(p.p, p.a)
val <- mapply(function(w,x,y,z) c(rnorm(w, x, 0.1),
rnorm(y, z, 0.1)), np, p.p, na, p.a)
df1 <- data.frame(species = rep(letters[1:5], each = n.occ),
pa = as.vector(pa),
value = as.vector(val))
head(df1)
ggplot(df1, aes(x = as.factor(pa), y = value))+
geom_boxplot()+
facet_wrap(~species)
ggplot(df1, aes(x = as.factor(pa), y = value))+
geom_boxplot()+
facet_wrap(~species)+
xlab("Presence - Absence")
dismo::evaluate(p = df1[df1$species == "a" & df1$pa == 1],
df1[df1$species == "a" & df1$pa == 0])
dismo::evaluate(p = df1[df1$species == "a" & df1$pa == 1],
a = df1[df1$species == "a" & df1$pa == 0])
head(df1)
dismo::evaluate(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
e <- dismo::evaluate(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
plot(e, "ROC")
str(e)
dismo::evaluateROCR(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
plot(dismo::evaluateROCR(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"]))
ROCR::plot(dismo::evaluateROCR(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"]))
library(dismo)
evaluate(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
e <- evaluate(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
plot(e, "ROC")
dismo:::auctest()
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
w$auc <- as.vector(w$statistic) / (e@na * e@np)
}
auctest(e)
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
w$auc <- as.vector(w$statistic) / (e@na * e@np)
return(w)
}
auctest(e)
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
auc <- as.vector(w$statistic) / (e@na * e@np)
return(c(pauc, auc)
}
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
auc <- as.vector(w$statistic) / (e@na * e@np)
return(c(pauc, auc))
}
auctest(e)
auc <- df1 %>%
group_by(species)%>%
evaluate(p = value[pa == 1], a = value[pa == 0])
auc <- sapply(split(df1, df1$species), function(x) evaluate(p = x$value[x$pa == 1],a = x$value[x$pa == 0]))
auc
auc <- sapply(split(df1, df1$species), function(x) evaluate(p = x$value[x$pa == 1],a = x$value[x$pa == 0])@auc)
auc
auc <- sapply(split(df1, df1$species), function(x) evaluate(p = x$value[x$pa == 1],a = x$value[x$pa == 0]))
eList <- sapply(split(df1, df1$species), function(x) evaluate(p = x$value[x$pa == 1],a = x$value[x$pa == 0]))
sapply(eList, function(x) x@auc)
sapply(eList, plot, "ROC")
par(mfcol = c(2,5))
sapply(split(df1, df1$species), function(x) boxplot(x$value ~ x$pa))
par(mfcol = c(2,5))
sapply(eList, plot, "ROC")
par(mfrow = c(2,5))
sapply(split(df1, df1$species), function(x) boxplot(x$value ~ x$pa))
sapply(eList, plot, "ROC")
set.seed(101)
n.spp <- 5
n.occ <- 100
np <- floor(runif(n, 20,60))
na <- n.occ - np
pa <- mapply(function(x,y) rep(c(1,0), c(x, y)), np, na)
p.p <- c(0.5, 0.8,0.4, 0.7,0.4)
p.a <- c(0.5, 0.6,0.6, 0.4,0.8)
cbind(p.p, p.a)
val <- mapply(function(w,x,y,z) c(rnorm(w, x, 0.1),
rnorm(y, z, 0.1)), np, p.p, na, p.a)
df1 <- data.frame(species = rep(letters[1:5], each = n.occ),
pa = as.vector(pa),
value = as.vector(val))
head(df1)
library(ggplot2)
ggplot(df1, aes(x = as.factor(pa), y = value))+
geom_boxplot()+
facet_wrap(~species)+
xlab("Presence - Absence")
e <- evaluate(p = df1[df1$species == "a" & df1$pa == 1, "value"],
a = df1[df1$species == "a" & df1$pa == 0, "value"])
e
plot(e, "ROC")
eList <- sapply(split(df1, df1$species), function(x) evaluate(p = x$value[x$pa == 1],a = x$value[x$pa == 0]))
sapply(eList, function(x) x@auc)
par(mfrow = c(2,5))
sapply(split(df1, df1$species), function(x) boxplot(x$value ~ x$pa))
sapply(eList, plot, "ROC")
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
auc <- as.vector(w$statistic) / (e@na * e@np)
return(c(pauc, auc))
}
auctest(e)
auctest <- function(e) {
w <- wilcox.test(e@presence, e@absence)
pauc <- w$p.value
auc <- as.vector(w$statistic) / (e@na * e@np)
return(auc)
}
auctest(e)
sapply(eList, auctest)
# testing data: 17 sites (20%) with response and predicted values from pa cross validation, 4 species
Y.test <- structure(c(1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1,
1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,
0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0,
0, 0, 0, 0, 0, 0, 0, 0, 0), .Dim = c(17L, 4L))
Pred.test <- structure(c(0.93892, 0.66146, 0.47845, 0.84288, 0.3483, 0.415,
0.97109, 0.91469, 0.86533, 0.76702, 0.6164, 0.91962, 0.78906,
0.91927, 0.73108, 0.83802, 0.92296, 0.60071, 0.13734, 0.29069,
0.35382, 0.11483, 0.17761, 0.3793, 0.15075, 0.41787, 0.33493,
0.24288, 0.14474, 0.19351, 0.33881, 0.13977, 0.11995, 0.12558,
0.53059, 0.85161, 0.84674, 0.95095, 0.81294, 0.99165, 0.34469,
0.85878, 0.65415, 0.42095, 0.92685, 0.89672, 0.88219, 0.85416,
0.97768, 0.97595, 0.91641, 0.34734, 0.18854, 0.10646, 0.27799,
0.28179, 0.48508, 0.11032, 0.24834, 0.14395, 0.18885, 0.21009,
0.18454, 0.16242, 0.21792, 0.26658, 0.19304, 0.14045),
.Dim = c(17L, 4L), .Dimnames = list(NULL, NULL))
Y.test
Pred.test
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
rocList <- lapply(1:ncol(Pred.test), function(i) pROC::roc(Y.test[,i],Pred.test[,i], direction = "<"))
sapply(1:ncol(Pred.test), function(i) as.numeric(dismo::evaluate(Y.test[,i],Pred.test[,i])@auc))
Y.test
Pred.test
sapply(1:ncol(Pred.test), function(i) as.numeric(dismo::evaluate(Pred.test[Y.test[,i]==1,i], Pred.test[Y.test[,i]==0,i])@auc))
sapply(1:ncol(Pred.test), function(i) as.numeric(pROC::roc(Y.test[,i],Pred.test[,i])$auc))
sapply(1:ncol(Pred.test), function(i) Metrics::auc(Y.test[,i],Pred.test[,i]))
par(mfcol = c(2,2))
for(i in 1:4){
plot(rocList[[i]])
text(1, 0.8, paste("direction:", rocList[[i]]["direction"]))
boxplot(Pred.test[,i] ~ Y.test[,i])
}
sapply(split(df1, df1$species), function(x) pROC::roc(data = x, response = "pa", predictor = value))
sapply(split(df1, df1$species), function(x) pROC::roc(data = x, response = "pa", predictor = value)$auc)
sapply(split(df1, df1$species), function(x) plot(pROC::roc(data = x, response = "pa", predictor = value)))
par(mfrow = c(4,5))
sapply(split(df1, df1$species), function(x) boxplot(x$value ~ x$pa))
sapply(eList, plot, "ROC")
sapply(split(df1, df1$species), function(x) plot(pROC::roc(data = x, response = "pa", predictor = value)))
sapply(split(df1, df1$species), function(x) plot(pROC::roc(data = x, response = "pa", predictor = value, direction = "<")))
